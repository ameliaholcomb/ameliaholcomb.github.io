<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>Amelia Holcomb</title>

    <link rel="stylesheet" href="../stylesheets/styles.css">
    <link rel="stylesheet" href="../stylesheets/pygment_trac.css">
    <meta name="viewport" content="width=device-width">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="wrapper">
      <header>
        <h1>Amelia Holcomb</h1>
        <p>Software Engineer</p>
        <a href='../index.html'> <img id="main" src="../images/P1560217.JPG"/> </a>

        <ul>
          <li><a href="https://github.com/ameliaholcomb">Fork On<strong>GitHub</strong></a>
          <li><a href="https://www.linkedin.com/in/amelia-holcomb-62a9a03b">Connect On<strong>LinkedIn</strong></a>
          <li><a href='downloads/Resume.pdf'> Download <strong> Resume </strong> </a>
          <li><a href="mailto:amelia.holcomb@gmail.com"> Email me at <strong>amelia.holcomb@gmail.com </strong></a>

        </ul>
      </header>
      <section>
        <h2> Parallelized Sparse Matrix Multiplication </h2>
        <p><i>with Jiaao Hou</i></p>
        <div>
          <p> The initial inspiration for our project came from thinking about the earliest published iteration of Googleâ€™s pagerank algorithm, which computes an adapted version of eigenvector centrality for the graph of internet websites (vertices are web pages and directed edges are hyperlinks between them). Rather than computing the eigenvectors of the adapted adjacency matrix directly, which is often computationally costly, the matrix can be understood as a Markov matrix and its stable state approximated by raising the matrix to very high powers. </p>
          <p> In this project, we took on that last step and wrote code to raise the matrix to high powers in parallel. We noted that internet graphs tend to be very sparse: two randomly chosen pages are extremely unlikely to link to one another. Thus, we decided to parallelize sparse matrix multiplication, in particular taking large powers of sparse matrices. We sought to implement a program that would perform no extra computation (eg would not expand out and multiply any zero matrix entries) and, when using OpenMPI, would not send any zero matrix entries between processes. </p>
          <p> In best conditions (2048 x 2048 matrix, power of 32), we were able to acheive up to 5.7x speedup with 8 processes over the original serial code. The algorithm also proved highly scalable, with increased speedup as matrix size increased. </p>

          <a href="https://github.com/jiggoha/pagerank_matrix_multiplication" target="_blank"> Check out the code on GitHub <a>

        </div>

        <small> <a href="../index.html">  home </a> </small></p>   

      </section>
    </div>
    <script src="javascripts/scale.fix.js"></script>
  </body>
</html>